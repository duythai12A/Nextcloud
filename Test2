curl -v -X POST "http://svg-sanitizer:3000/sanitize" \
  -H "Content-Type: image/svg+xml" \
  --data-binary '<svg xmlns="http://www.w3.org/2000/svg"><script>alert(1)</script></svg>'

curl -v -X POST "http://svg-sanitizer:3000/sanitize" \
  -H "Content-Type: image/svg+xml" \
  --data-binary '<svg xmlns="http://www.w3.org/2000/svg"><rect width="10" height="10"/></svg>'

<?php
declare(strict_types=1);

namespace OCA\SvgSanitizer\Listener;

use OCP\EventDispatcher\Event;
use OCP\EventDispatcher\IEventListener;
use OCP\Http\Client\IClientService;
use Psr\Log\LoggerInterface;

use OCP\Files\File;
use OCP\Files\ForbiddenException;

use OCP\Files\Events\Node\NodeWrittenEvent;
use OCP\Files\Events\BeforeDirectFileDownloadEvent;

class SvgSanitizeListener implements IEventListener {

    private IClientService $clientService;
    private LoggerInterface $logger;

    // Hardcode cho nhanh; nếu muốn configurable bằng occ thì mình gửi thêm đoạn đọc app config
    private string $endpoint = 'http://svg-sanitizer:3000/sanitize';

    public function __construct(IClientService $clientService, LoggerInterface $logger) {
        $this->clientService = $clientService;
        $this->logger = $logger;
    }

    public function handle(Event $event): void {

        // ===== 1) Sau khi ghi xong file: đọc content và chặn =====
        if ($event instanceof NodeWrittenEvent) {
            $node = $event->getNode();

            if (!($node instanceof File)) {
                return;
            }

            if (strtolower((string)$node->getExtension()) !== 'svg') {
                return;
            }

            $name = $node->getName();

            // Size limit (1MB)
            $size = (int)$node->getSize();
            if ($size > 1024 * 1024) {
                $this->logger->warning("SVG_SANITIZER: too large -> delete {$name}");
                $node->delete();
                throw new ForbiddenException('SVG blocked: too large');
            }

            // Đọc content (lúc này đã tồn tại thật)
            $svg = (string)$node->getContent();

            // Chặn ngay nếu có <script ...> (không phụ thuộc service)
            if ($this->containsScript($svg)) {
                $this->logger->warning("SVG_SANITIZER: <script> detected -> delete {$name}");
                $node->delete();
                throw new ForbiddenException('SVG blocked: script tag detected');
            }

            // Gọi sanitizer service (optional nhưng bạn yêu cầu)
            try {
                $client = $this->clientService->newClient();
                $resp = $client->post($this->endpoint, [
                    'headers' => ['Content-Type' => 'image/svg+xml'],
                    'body' => $svg,
                    'timeout' => 5,
                ]);
                $data = json_decode((string)$resp->getBody(), true);
            } catch (\Throwable $e) {
                // Policy: sanitizer lỗi => chặn
                $this->logger->error("SVG_SANITIZER: sanitizer call failed -> delete {$name}. Err=" . $e->getMessage());
                $node->delete();
                throw new ForbiddenException('SVG blocked: sanitizer unreachable');
            }

            if (!is_array($data) || empty($data['ok']) || !array_key_exists('clean', $data)) {
                $this->logger->error("SVG_SANITIZER: invalid sanitizer response -> delete {$name}");
                $node->delete();
                throw new ForbiddenException('SVG blocked: sanitize failed');
            }

            if (!empty($data['dirty'])) {
                $this->logger->warning("SVG_SANITIZER: sanitizer marked dirty -> delete {$name}");
                $node->delete();
                throw new ForbiddenException('SVG blocked: malicious content');
            }

            // Ghi đè bản clean (nếu service có normalize/remove gì đó)
            $node->putContent((string)$data['clean']);
            $this->logger->warning("SVG_SANITIZER: sanitized OK {$name}");

            return;
        }

        // ===== 2) Optional: chặn download SVG luôn (hoặc tùy policy) =====
        if ($event instanceof BeforeDirectFileDownloadEvent) {
            $node = null;

            if (method_exists($event, 'getNode')) {
                $node = $event->getNode();
            } elseif (method_exists($event, 'getFile')) {
                $node = $event->getFile();
            }

            if ($node instanceof File && strtolower((string)$node->getExtension()) === 'svg') {
                // Nếu bạn chỉ muốn chặn SVG có script thì:
                // - đọc content và check containsScript rồi throw
                // Nhưng download event có thể tốn tài nguyên, nên mặc định chặn download SVG luôn để an toàn.
                $this->logger->warning("SVG_SANITIZER: block direct download of SVG: " . $node->getName());
                throw new ForbiddenException('SVG download blocked');
            }

            return;
        }
    }

    private function containsScript(string $svg): bool {
        // Chặn <script ...> (case-insensitive) + các dạng script tag có namespace
        if (preg_match('/<\s*(?:svg:)?script\b/i', $svg)) {
            return true;
        }
        // Nếu bạn muốn chặn luôn event handler kiểu onload=, onclick= thì bật thêm:
        // if (preg_match('/\bon\w+\s*=\s*["\']?/i', $svg)) return true;
        return false;
    }
}
